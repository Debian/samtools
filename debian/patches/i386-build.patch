Description: Fix build on i386
 This is a backport of the upstream patch linked below because the patch from
 this commit did not cleanly apply.
Origin: upstream, https://github.com/samtools/samtools/commit/5c3b72714acf36506a2ad8429927b502ac8966c1
Bug: https://github.com/samtools/samtools/issues/305
Applied-Upstream: https://github.com/samtools/samtools/commit/5c3b72714acf36506a2ad8429927b502ac8966c1
Last-Update: 2015-09-13
--- samtools.orig/bam2bcf.h
+++ samtools/bam2bcf.h
@@ -56,7 +56,8 @@
     int capQ, min_baseQ;
     int openQ, extQ, tandemQ; // for indels
     uint32_t min_support, max_support; // for collecting indel candidates
-    float min_frac, max_frac; // for collecting indel candidates
+    double min_frac; // for collecting indel candidates
+    float max_frac; // for collecting indel candidates
     int per_sample_flt; // indel filtering strategy
     int *ref_pos, *alt_pos, npos, *ref_mq, *alt_mq, *ref_bq, *alt_bq, *fwd_mqs, *rev_mqs, nqual; // for bias tests
     // for internal uses
--- samtools.orig/bam2bcf_indel.c
+++ samtools/bam2bcf_indel.c
@@ -26,6 +26,7 @@
 #include <assert.h>
 #include <ctype.h>
 #include <string.h>
+#include <float.h>
 #include "htslib/sam.h"
 #include "bam2bcf.h"
 #include "kprobaln.h"
@@ -199,7 +200,7 @@
                 j = bam_cigar2qlen(p->b->core.n_cigar, bam_get_cigar(p->b));
                 if (j > max_rd_len) max_rd_len = j;
             }
-            float frac = (float)na/nt;
+            double frac = (double)na/nt;
             if ( !indel_support_ok && na >= bca->min_support && frac >= bca->min_frac )
                 indel_support_ok = 1;
             if ( na > bca->max_support && frac > 0 ) bca->max_support = na, bca->max_frac = frac;
@@ -217,7 +218,8 @@
             if (aux[i] != aux[i-1]) ++n_types;
         // Taking totals makes it hard to call rare indels
         if ( !bca->per_sample_flt )
-            indel_support_ok = ( (float)n_alt / n_tot < bca->min_frac || n_alt < bca->min_support ) ? 0 : 1;
+            indel_support_ok = ( (float)n_alt / n_tot < bca->min_frac
+                                 || n_alt < bca->min_support ) ? 0 : 1;
         if ( n_types == 1 || !indel_support_ok ) { // then skip
             free(aux); return -1;
         }
